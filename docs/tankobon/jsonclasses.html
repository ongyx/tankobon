<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tankobon.jsonclasses API documentation</title>
<meta name="description" content="Wraps the json module to allow (de)serializing dataclasses.
(As long as your dataclass uses only the basic JSON types, no nested classes.) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tankobon.jsonclasses</code></h1>
</header>
<section id="section-intro">
<p>Wraps the json module to allow (de)serializing dataclasses.
(As long as your dataclass uses only the basic JSON types, no nested classes.)</p>
<p>To use, just replace any <code>dataclasses</code> import with <code>jsonclasses</code>.
jsonclasses automatically monkeypatches the json module so that it can dump any dataclasses created using the <code>@jsonclasses.dataclass</code> decorator.</p>
<p>NOTE: Any dataclass fields that start with <code>_</code> (i.e <code>_data</code>) <strong>will</strong> be treated as private and will not be serialised.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf8
&#34;&#34;&#34;Wraps the json module to allow (de)serializing dataclasses.
(As long as your dataclass uses only the basic JSON types, no nested classes.)

To use, just replace any `dataclasses` import with `jsonclasses`.
jsonclasses automatically monkeypatches the json module so that it can dump any dataclasses created using the `@jsonclasses.dataclass` decorator.

NOTE: Any dataclass fields that start with `_` (i.e `_data`) **will** be treated as private and will not be serialised.
&#34;&#34;&#34;

import functools
import json
from dataclasses import (
    dataclass as _dataclass,
    field,
    Field,
    FrozenInstanceError,
    InitVar,
    MISSING,
    fields,
    asdict,
    astuple,
    make_dataclass,
    replace,
    is_dataclass,
)
from typing import Any, Dict

__all__ = [
    &#34;dataclass&#34;,
    &#34;field&#34;,
    &#34;Field&#34;,
    &#34;FrozenInstanceError&#34;,
    &#34;InitVar&#34;,
    &#34;MISSING&#34;,
    &#34;fields&#34;,
    &#34;asdict&#34;,
    &#34;astuple&#34;,
    &#34;make_dataclass&#34;,
    &#34;replace&#34;,
    &#34;is_dataclass&#34;,
]


_DATACLASSES: Dict[str, Any] = {}


def dataclass(cls=None, **kwargs):
    def wrap(cls):
        _DATACLASSES[cls.__name__] = cls
        return _dataclass(cls, **kwargs)

    if cls is None:
        return wrap

    return wrap(cls)


def _encode(o):
    if is_dataclass(o):
        new_o = {k: v for k, v in o.__dict__.items() if not k.startswith(&#34;_&#34;)}
        new_o[&#34;__dataclass__&#34;] = o.__class__.__name__
        return new_o

    return json.JSONEncoder().default(o)


def _decode(o):
    if &#34;__dataclass__&#34; in o:
        cls = _DATACLASSES[o.pop(&#34;__dataclass__&#34;)]
        return cls(**o)
    return o


# monkey-patch load(s) and dump(s)
json.loads = functools.partial(json.loads, object_hook=_decode)
json.load = functools.partial(json.load, object_hook=_decode)
json.dumps = functools.partial(json.dumps, default=_encode)
json.dump = functools.partial(json.dump, default=_encode)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tankobon.jsonclasses.asdict"><code class="name flex">
<span>def <span class="ident">asdict</span></span>(<span>obj, *, dict_factory=builtins.dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fields of a dataclass instance as a new dictionary mapping
field names to field values.</p>
<p>Example usage:</p>
<p>@dataclass
class C:
x: int
y: int</p>
<p>c = C(1, 2)
assert asdict(c) == {'x': 1, 'y': 2}</p>
<p>If given, 'dict_factory' will be used instead of built-in dict.
The function applies recursively to field values that are
dataclass instances. This will also look into built-in containers:
tuples, lists, and dicts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asdict(obj, *, dict_factory=dict):
    &#34;&#34;&#34;Return the fields of a dataclass instance as a new dictionary mapping
    field names to field values.

    Example usage:

      @dataclass
      class C:
          x: int
          y: int

      c = C(1, 2)
      assert asdict(c) == {&#39;x&#39;: 1, &#39;y&#39;: 2}

    If given, &#39;dict_factory&#39; will be used instead of built-in dict.
    The function applies recursively to field values that are
    dataclass instances. This will also look into built-in containers:
    tuples, lists, and dicts.
    &#34;&#34;&#34;
    if not _is_dataclass_instance(obj):
        raise TypeError(&#34;asdict() should be called on dataclass instances&#34;)
    return _asdict_inner(obj, dict_factory)</code></pre>
</details>
</dd>
<dt id="tankobon.jsonclasses.astuple"><code class="name flex">
<span>def <span class="ident">astuple</span></span>(<span>obj, *, tuple_factory=builtins.tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fields of a dataclass instance as a new tuple of field values.</p>
<p>Example usage::</p>
<p>@dataclass
class C:
x: int
y: int</p>
<p>c = C(1, 2)
assert astuple(c) == (1, 2)</p>
<p>If given, 'tuple_factory' will be used instead of built-in tuple.
The function applies recursively to field values that are
dataclass instances. This will also look into built-in containers:
tuples, lists, and dicts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astuple(obj, *, tuple_factory=tuple):
    &#34;&#34;&#34;Return the fields of a dataclass instance as a new tuple of field values.

    Example usage::

      @dataclass
      class C:
          x: int
          y: int

    c = C(1, 2)
    assert astuple(c) == (1, 2)

    If given, &#39;tuple_factory&#39; will be used instead of built-in tuple.
    The function applies recursively to field values that are
    dataclass instances. This will also look into built-in containers:
    tuples, lists, and dicts.
    &#34;&#34;&#34;

    if not _is_dataclass_instance(obj):
        raise TypeError(&#34;astuple() should be called on dataclass instances&#34;)
    return _astuple_inner(obj, tuple_factory)</code></pre>
</details>
</dd>
<dt id="tankobon.jsonclasses.dataclass"><code class="name flex">
<span>def <span class="ident">dataclass</span></span>(<span>cls=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataclass(cls=None, **kwargs):
    def wrap(cls):
        _DATACLASSES[cls.__name__] = cls
        return _dataclass(cls, **kwargs)

    if cls is None:
        return wrap

    return wrap(cls)</code></pre>
</details>
</dd>
<dt id="tankobon.jsonclasses.field"><code class="name flex">
<span>def <span class="ident">field</span></span>(<span>*, default=&lt;dataclasses._MISSING_TYPE object&gt;, default_factory=&lt;dataclasses._MISSING_TYPE object&gt;, init=True, repr=True, hash=None, compare=True, metadata=None, kw_only=&lt;dataclasses._MISSING_TYPE object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an object to identify dataclass fields.</p>
<p>default is the default value of the field.
default_factory is a
0-argument function called to initialize a field's value.
If init
is true, the field will be a parameter to the class's <strong>init</strong>()
function.
If repr is true, the field will be included in the
object's repr().
If hash is true, the field will be included in the
object's hash().
If compare is true, the field will be used in
comparison functions.
metadata, if specified, must be a mapping
which is stored but not otherwise examined by dataclass.
If kw_only
is true, the field will become a keyword-only parameter to
<strong>init</strong>().</p>
<p>It is an error to specify both default and default_factory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field(*, default=MISSING, default_factory=MISSING, init=True, repr=True,
          hash=None, compare=True, metadata=None, kw_only=MISSING):
    &#34;&#34;&#34;Return an object to identify dataclass fields.

    default is the default value of the field.  default_factory is a
    0-argument function called to initialize a field&#39;s value.  If init
    is true, the field will be a parameter to the class&#39;s __init__()
    function.  If repr is true, the field will be included in the
    object&#39;s repr().  If hash is true, the field will be included in the
    object&#39;s hash().  If compare is true, the field will be used in
    comparison functions.  metadata, if specified, must be a mapping
    which is stored but not otherwise examined by dataclass.  If kw_only
    is true, the field will become a keyword-only parameter to
    __init__().

    It is an error to specify both default and default_factory.
    &#34;&#34;&#34;

    if default is not MISSING and default_factory is not MISSING:
        raise ValueError(&#39;cannot specify both default and default_factory&#39;)
    return Field(default, default_factory, init, repr, hash, compare,
                 metadata, kw_only)</code></pre>
</details>
</dd>
<dt id="tankobon.jsonclasses.fields"><code class="name flex">
<span>def <span class="ident">fields</span></span>(<span>class_or_instance)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a tuple describing the fields of this dataclass.</p>
<p>Accepts a dataclass or an instance of one. Tuple elements are of
type Field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fields(class_or_instance):
    &#34;&#34;&#34;Return a tuple describing the fields of this dataclass.

    Accepts a dataclass or an instance of one. Tuple elements are of
    type Field.
    &#34;&#34;&#34;

    # Might it be worth caching this, per class?
    try:
        fields = getattr(class_or_instance, _FIELDS)
    except AttributeError:
        raise TypeError(&#39;must be called with a dataclass type or instance&#39;)

    # Exclude pseudo-fields.  Note that fields is sorted by insertion
    # order, so the order of the tuple is as the fields were defined.
    return tuple(f for f in fields.values() if f._field_type is _FIELD)</code></pre>
</details>
</dd>
<dt id="tankobon.jsonclasses.is_dataclass"><code class="name flex">
<span>def <span class="ident">is_dataclass</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if obj is a dataclass or an instance of a
dataclass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_dataclass(obj):
    &#34;&#34;&#34;Returns True if obj is a dataclass or an instance of a
    dataclass.&#34;&#34;&#34;
    cls = obj if isinstance(obj, type) and not isinstance(obj, GenericAlias) else type(obj)
    return hasattr(cls, _FIELDS)</code></pre>
</details>
</dd>
<dt id="tankobon.jsonclasses.make_dataclass"><code class="name flex">
<span>def <span class="ident">make_dataclass</span></span>(<span>cls_name, fields, *, bases=(), namespace=None, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new dynamically created dataclass.</p>
<p>The dataclass name will be 'cls_name'.
'fields' is an iterable
of either (name), (name, type) or (name, type, Field) objects. If type is
omitted, use the string 'typing.Any'.
Field objects are created by
the equivalent of calling 'field(name, type [, Field-info])'.</p>
<p>C = make_dataclass('C', ['x', ('y', int), ('z', int, field(init=False))], bases=(Base,))</p>
<p>is equivalent to:</p>
<p>@dataclass
class C(Base):
x: 'typing.Any'
y: int
z: int = field(init=False)</p>
<p>For the bases and namespace parameters, see the builtin type() function.</p>
<p>The parameters init, repr, eq, order, unsafe_hash, and frozen are passed to
dataclass().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True,
                   repr=True, eq=True, order=False, unsafe_hash=False,
                   frozen=False, match_args=True, kw_only=False, slots=False):
    &#34;&#34;&#34;Return a new dynamically created dataclass.

    The dataclass name will be &#39;cls_name&#39;.  &#39;fields&#39; is an iterable
    of either (name), (name, type) or (name, type, Field) objects. If type is
    omitted, use the string &#39;typing.Any&#39;.  Field objects are created by
    the equivalent of calling &#39;field(name, type [, Field-info])&#39;.

      C = make_dataclass(&#39;C&#39;, [&#39;x&#39;, (&#39;y&#39;, int), (&#39;z&#39;, int, field(init=False))], bases=(Base,))

    is equivalent to:

      @dataclass
      class C(Base):
          x: &#39;typing.Any&#39;
          y: int
          z: int = field(init=False)

    For the bases and namespace parameters, see the builtin type() function.

    The parameters init, repr, eq, order, unsafe_hash, and frozen are passed to
    dataclass().
    &#34;&#34;&#34;

    if namespace is None:
        namespace = {}

    # While we&#39;re looking through the field names, validate that they
    # are identifiers, are not keywords, and not duplicates.
    seen = set()
    annotations = {}
    defaults = {}
    for item in fields:
        if isinstance(item, str):
            name = item
            tp = &#39;typing.Any&#39;
        elif len(item) == 2:
            name, tp, = item
        elif len(item) == 3:
            name, tp, spec = item
            defaults[name] = spec
        else:
            raise TypeError(f&#39;Invalid field: {item!r}&#39;)

        if not isinstance(name, str) or not name.isidentifier():
            raise TypeError(f&#39;Field names must be valid identifiers: {name!r}&#39;)
        if keyword.iskeyword(name):
            raise TypeError(f&#39;Field names must not be keywords: {name!r}&#39;)
        if name in seen:
            raise TypeError(f&#39;Field name duplicated: {name!r}&#39;)

        seen.add(name)
        annotations[name] = tp

    # Update &#39;ns&#39; with the user-supplied namespace plus our calculated values.
    def exec_body_callback(ns):
        ns.update(namespace)
        ns.update(defaults)
        ns[&#39;__annotations__&#39;] = annotations

    # We use `types.new_class()` instead of simply `type()` to allow dynamic creation
    # of generic dataclasses.
    cls = types.new_class(cls_name, bases, {}, exec_body_callback)

    # Apply the normal decorator.
    return dataclass(cls, init=init, repr=repr, eq=eq, order=order,
                     unsafe_hash=unsafe_hash, frozen=frozen,
                     match_args=match_args, kw_only=kw_only, slots=slots)</code></pre>
</details>
</dd>
<dt id="tankobon.jsonclasses.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>obj, /, **changes)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new object replacing specified fields with new values.</p>
<p>This is especially useful for frozen classes.
Example usage:</p>
<p>@dataclass(frozen=True)
class C:
x: int
y: int</p>
<p>c = C(1, 2)
c1 = replace(c, x=3)
assert c1.x == 3 and c1.y == 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(obj, /, **changes):
    &#34;&#34;&#34;Return a new object replacing specified fields with new values.

    This is especially useful for frozen classes.  Example usage:

      @dataclass(frozen=True)
      class C:
          x: int
          y: int

      c = C(1, 2)
      c1 = replace(c, x=3)
      assert c1.x == 3 and c1.y == 2
      &#34;&#34;&#34;

    # We&#39;re going to mutate &#39;changes&#39;, but that&#39;s okay because it&#39;s a
    # new dict, even if called with &#39;replace(obj, **my_changes)&#39;.

    if not _is_dataclass_instance(obj):
        raise TypeError(&#34;replace() should be called on dataclass instances&#34;)

    # It&#39;s an error to have init=False fields in &#39;changes&#39;.
    # If a field is not in &#39;changes&#39;, read its value from the provided obj.

    for f in getattr(obj, _FIELDS).values():
        # Only consider normal fields or InitVars.
        if f._field_type is _FIELD_CLASSVAR:
            continue

        if not f.init:
            # Error if this field is specified in changes.
            if f.name in changes:
                raise ValueError(f&#39;field {f.name} is declared with &#39;
                                 &#39;init=False, it cannot be specified with &#39;
                                 &#39;replace()&#39;)
            continue

        if f.name not in changes:
            if f._field_type is _FIELD_INITVAR and f.default is MISSING:
                raise ValueError(f&#34;InitVar {f.name!r} &#34;
                                 &#39;must be specified with replace()&#39;)
            changes[f.name] = getattr(obj, f.name)

    # Create the new object, which calls __init__() and
    # __post_init__() (if defined), using all of the init fields we&#39;ve
    # added and/or left in &#39;changes&#39;.  If there are values supplied in
    # changes that aren&#39;t fields, this will correctly raise a
    # TypeError.
    return obj.__class__(**changes)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tankobon.jsonclasses.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
<span>(</span><span>default, default_factory, init, repr, hash, compare, metadata, kw_only)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field:
    __slots__ = (&#39;name&#39;,
                 &#39;type&#39;,
                 &#39;default&#39;,
                 &#39;default_factory&#39;,
                 &#39;repr&#39;,
                 &#39;hash&#39;,
                 &#39;init&#39;,
                 &#39;compare&#39;,
                 &#39;metadata&#39;,
                 &#39;kw_only&#39;,
                 &#39;_field_type&#39;,  # Private: not to be used by user code.
                 )

    def __init__(self, default, default_factory, init, repr, hash, compare,
                 metadata, kw_only):
        self.name = None
        self.type = None
        self.default = default
        self.default_factory = default_factory
        self.init = init
        self.repr = repr
        self.hash = hash
        self.compare = compare
        self.metadata = (_EMPTY_METADATA
                         if metadata is None else
                         types.MappingProxyType(metadata))
        self.kw_only = kw_only
        self._field_type = None

    def __repr__(self):
        return (&#39;Field(&#39;
                f&#39;name={self.name!r},&#39;
                f&#39;type={self.type!r},&#39;
                f&#39;default={self.default!r},&#39;
                f&#39;default_factory={self.default_factory!r},&#39;
                f&#39;init={self.init!r},&#39;
                f&#39;repr={self.repr!r},&#39;
                f&#39;hash={self.hash!r},&#39;
                f&#39;compare={self.compare!r},&#39;
                f&#39;metadata={self.metadata!r},&#39;
                f&#39;kw_only={self.kw_only!r},&#39;
                f&#39;_field_type={self._field_type}&#39;
                &#39;)&#39;)

    # This is used to support the PEP 487 __set_name__ protocol in the
    # case where we&#39;re using a field that contains a descriptor as a
    # default value.  For details on __set_name__, see
    # https://www.python.org/dev/peps/pep-0487/#implementation-details.
    #
    # Note that in _process_class, this Field object is overwritten
    # with the default value, so the end result is a descriptor that
    # had __set_name__ called on it at the right time.
    def __set_name__(self, owner, name):
        func = getattr(type(self.default), &#39;__set_name__&#39;, None)
        if func:
            # There is a __set_name__ method on the descriptor, call
            # it.
            func(self.default, owner, name)

    __class_getitem__ = classmethod(GenericAlias)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tankobon.jsonclasses.Field.compare"><code class="name">var <span class="ident">compare</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.default"><code class="name">var <span class="ident">default</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.default_factory"><code class="name">var <span class="ident">default_factory</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.hash"><code class="name">var <span class="ident">hash</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.init"><code class="name">var <span class="ident">init</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.kw_only"><code class="name">var <span class="ident">kw_only</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.repr"><code class="name">var <span class="ident">repr</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tankobon.jsonclasses.Field.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="tankobon.jsonclasses.FrozenInstanceError"><code class="flex name class">
<span>class <span class="ident">FrozenInstanceError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Attribute not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrozenInstanceError(AttributeError): pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.AttributeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="tankobon.jsonclasses.InitVar"><code class="flex name class">
<span>class <span class="ident">InitVar</span></span>
<span>(</span><span>type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InitVar:
    __slots__ = (&#39;type&#39;, )

    def __init__(self, type):
        self.type = type

    def __repr__(self):
        if isinstance(self.type, type) and not isinstance(self.type, GenericAlias):
            type_name = self.type.__name__
        else:
            # typing objects, e.g. List[int]
            type_name = repr(self.type)
        return f&#39;dataclasses.InitVar[{type_name}]&#39;

    def __class_getitem__(cls, type):
        return InitVar(type)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tankobon.jsonclasses.InitVar.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tankobon" href="index.html">tankobon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tankobon.jsonclasses.asdict" href="#tankobon.jsonclasses.asdict">asdict</a></code></li>
<li><code><a title="tankobon.jsonclasses.astuple" href="#tankobon.jsonclasses.astuple">astuple</a></code></li>
<li><code><a title="tankobon.jsonclasses.dataclass" href="#tankobon.jsonclasses.dataclass">dataclass</a></code></li>
<li><code><a title="tankobon.jsonclasses.field" href="#tankobon.jsonclasses.field">field</a></code></li>
<li><code><a title="tankobon.jsonclasses.fields" href="#tankobon.jsonclasses.fields">fields</a></code></li>
<li><code><a title="tankobon.jsonclasses.is_dataclass" href="#tankobon.jsonclasses.is_dataclass">is_dataclass</a></code></li>
<li><code><a title="tankobon.jsonclasses.make_dataclass" href="#tankobon.jsonclasses.make_dataclass">make_dataclass</a></code></li>
<li><code><a title="tankobon.jsonclasses.replace" href="#tankobon.jsonclasses.replace">replace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tankobon.jsonclasses.Field" href="#tankobon.jsonclasses.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="tankobon.jsonclasses.Field.compare" href="#tankobon.jsonclasses.Field.compare">compare</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.default" href="#tankobon.jsonclasses.Field.default">default</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.default_factory" href="#tankobon.jsonclasses.Field.default_factory">default_factory</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.hash" href="#tankobon.jsonclasses.Field.hash">hash</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.init" href="#tankobon.jsonclasses.Field.init">init</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.kw_only" href="#tankobon.jsonclasses.Field.kw_only">kw_only</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.metadata" href="#tankobon.jsonclasses.Field.metadata">metadata</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.name" href="#tankobon.jsonclasses.Field.name">name</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.repr" href="#tankobon.jsonclasses.Field.repr">repr</a></code></li>
<li><code><a title="tankobon.jsonclasses.Field.type" href="#tankobon.jsonclasses.Field.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tankobon.jsonclasses.FrozenInstanceError" href="#tankobon.jsonclasses.FrozenInstanceError">FrozenInstanceError</a></code></h4>
</li>
<li>
<h4><code><a title="tankobon.jsonclasses.InitVar" href="#tankobon.jsonclasses.InitVar">InitVar</a></code></h4>
<ul class="">
<li><code><a title="tankobon.jsonclasses.InitVar.type" href="#tankobon.jsonclasses.InitVar.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>