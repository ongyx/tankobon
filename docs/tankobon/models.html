<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tankobon.models API documentation</title>
<meta name="description" content="Model classes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tankobon.models</code></h1>
</header>
<section id="section-intro">
<p>Model classes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf8
&#34;&#34;&#34;Model classes.&#34;&#34;&#34;

from __future__ import annotations

import collections
import hashlib
import logging
from typing import cast, Any, Dict, List, Optional

import natsort  # type: ignore

from . import utils
from .jsonclasses import dataclass, field


# cast because mypy keeps complaining about generic types
def _list():
    return cast(List[Any], field(default_factory=list))


def _dict():
    return cast(Dict[str, Any], field(default_factory=dict))


_log = logging.getLogger(&#34;tankobon&#34;)


@dataclass
class Metadata:
    &#34;&#34;&#34;Metadata for a manga.

    Args:
        url: The url to the manga title page.
        title: The manga name in English (romanized/translated).
        alt_titles: A list of alternative names for the manga.
            i.e in another language, original Japanese name, etc.
        desc: The sypnosis (human-readable info) of the manga.
            This is a map of the ISO 639-1 language code to the localised description.
            At least &#39;en&#39; (English) should be present.
        cover: The url to the manga cover page (must be an image).
        authors: A list of author names.
        genres: A list of catagories the manga belongs to.
            i.e shounen, slice_of_life, etc.
            Note that the catagories are sanitised using utils.sanitise() on initalisation.
        other: Miscellanious map of keys to values.
            May be used by parsers to store parser-specific info (keep state).

    Attributes:
        hash: A SHA-256 checksum of the manga url.
            (Can be used for filename-safe manga storage.)
    &#34;&#34;&#34;

    url: str
    title: str = &#34;&#34;

    alt_titles: List[str] = _list()

    desc: Dict[str, str] = _dict()
    cover: str = &#34;&#34;

    authors: List[str] = _list()
    genres: List[str] = _list()

    hash: str = &#34;&#34;

    other: Dict[str, Any] = _dict()

    def __post_init__(self):
        if self.genres:
            self.genres = [utils.sanitize(g.strip()) for g in self.genres]

        for lang, localized in self.desc.items():
            self.desc[lang] = localized.strip().replace(&#34;\r\n&#34;, &#34;\n&#34;)

        if not self.hash:
            self.hash = hashlib.sha256(self.url.encode()).hexdigest()


@dataclass
class Chapter:
    &#34;&#34;&#34;A manga chapter.

    Args:
        id: The chapter id as a string (i.e 1, 2, 10a, etc.).
        url: The chapter url.
        title: The chapter name.
        volume: The volume the chapter belongs to.
        lang: The RFC 5646 (IETF) language code that this chapter was translated to.
            (i.e &#39;en&#39; - English)
        pages: A list of image urls to the chapter pages.
        other: Miscellanious map of keys to values.
            May be used by parsers to store parser-specific info (keep state).
    &#34;&#34;&#34;

    id: str
    url: str
    title: str = &#34;&#34;
    volume: str = &#34;0&#34;
    lang: str = &#34;en&#34;

    pages: List[str] = _list()

    other: Dict[str, Any] = _dict()


class Manga:
    &#34;&#34;&#34;A manga.

    Selecting chapters in this manga can be done by slicing:

    manga[start_cid:end_cid:lang]  # returns a list of Chapter objects

    where start_cid is the first chapter of the selection, and end_cid is the last chapter of the selection.
    lang is the ISO 639-1 language code of the chapters to select. i.e:

    # Select chapters 1 to 5 in the Spanish language (inclusive of chapter 5).
    # NOTE: If the chapter does not have a translation for the selected language,
    # the number of chapters you get may not be the number requested!
    chapters = manga[&#34;1&#34;:&#34;5&#34;:&#34;es&#34;]

    Args:
        meta: The manga metadata.
        chapters: The manga chapters.

    Attributes:
        chapters: A map of chapter ids to a map of ISO 639-1 language codes to Chapter objects (chapters may have several languages):

            {
                // chapter id
                &#34;1&#34;: {
                    // ISO 639-1 language code
                    &#34;en&#34;: Chapter(...)
                }
            }

        info: A dictionary which has the following keys:

            chapters (int)
                The total number of chapters across all languages.

            volumes (set)
                The volumes that this manga has across all languages.

            langs (set)
                ISO 639-1 language codes that this manga was translated to.
                Note that chapters may not have a translation for all language codes.
    &#34;&#34;&#34;

    def __init__(
        self,
        metadata: Metadata,
        chapters: Optional[dict] = None,
    ):
        self.meta = metadata

        self.chapters: Dict[str, Dict[str, Chapter]]

        self.chapters = collections.defaultdict(dict)

        if chapters is not None:
            self.chapters.update(chapters)

    @property
    def info(self):
        info = {
            &#34;chapters&#34;: 0,
            &#34;volumes&#34;: set(),
            &#34;langs&#34;: set(),
        }

        for cid, langs in self.chapters.items():
            info[&#34;langs&#34;].update(langs.keys())

            for chapter in langs.values():
                info[&#34;chapters&#34;] += 1
                info[&#34;volumes&#34;].add(chapter.volume)

        return info

    def add(self, chapter: Chapter):
        &#34;&#34;&#34;Add a chapter to this manga.
        The chapter will not be added if it already exists (has the same id and lang as the existing one).

        Args:
            chapter: The chapter to add.
        &#34;&#34;&#34;

        if not self.exists(chapter):
            self.chapters[chapter.id][chapter.lang] = chapter

    def remove(self, cid: str, lang: str = &#34;en&#34;) -&gt; Chapter:
        &#34;&#34;&#34;Remove a chapter from this manga.

        Args:
            cid: The chapter id to remove.
            lang: The chapter language to remove.
                Defaults to &#39;en&#39;.

        Returns:
            The removed chapter.
        &#34;&#34;&#34;

        return self.chapters[cid].pop(lang)

    def exists(self, chapter: Chapter) -&gt; bool:
        &#34;&#34;&#34;Check whether a chapter already exists in this manga.

        Args:
            chapter: The chapter object.

        Returns:
            True if it exists, otherwise False.
        &#34;&#34;&#34;

        langs = self.chapters.get(chapter.id, {})

        return bool(langs) and chapter.lang in langs

    def dump(self) -&gt; dict:
        &#34;&#34;&#34;Serialise this manga to a dict.&#34;&#34;&#34;
        return {&#34;meta&#34;: self.meta, &#34;chapters&#34;: self.chapters}

    @classmethod
    def load(cls, data: dict) -&gt; Manga:
        &#34;&#34;&#34;Deserialise this manga from a dict.

        Args:
            data: The serialised manga.

        Returns:
            The Manga object.
        &#34;&#34;&#34;
        return cls(data[&#34;meta&#34;], chapters=data[&#34;chapters&#34;])  # type: ignore

    def summary(self, lang: str = &#34;en&#34;, link: bool = True) -&gt; str:
        &#34;&#34;&#34;Create a Markdown table summary of all volumes and chapters in this manga.

        Args:
            lang: The language to summerise for.
            link: Whether or not to add URL links.
                Defaults to True.

        Returns:
            The Markdown table as a string.
        &#34;&#34;&#34;

        table = [&#34;| volume | chapter | title &#34;, &#34;|--------|---------|-------&#34;]

        for cid, langs in natsort.natsorted(self.chapters.items()):

            chapter: Chapter = langs.get(lang)

            if chapter is None:
                # chapter does not have the language.
                continue

            table.append(
                &#34;| {:&lt;6} | {:&lt;7} | {}&#34;.format(
                    chapter.volume or &#34;(empty)&#34;,
                    chapter.id or &#34;(empty)&#34;,
                    f&#34;[{chapter.title or &#39;(empty)&#39;}]({chapter.url})&#34;
                    if link
                    else chapter.title or &#34;(empty)&#34;,
                )
            )

        if len(table) == 2:
            table.append(
                f&#34;(No chapters available for the language &#39;{lang}&#39;. Maybe try another one?)&#34;
            )

        return &#34;\n&#34;.join(table)

    def select(self, cids: str, lang: str = &#34;en&#34;) -&gt; List[Chapter]:
        &#34;&#34;&#34;Select chapters from this manga.

        Args:
            cids: A list of chapter ids as a string, delimited by a comma.
                Ranges are also valid (1-5).
                i.e &#39;1,3,5,8-10&#39; (select chapters 1,3,5 and 8-10 inclusive of 10).
            lang: The language of the chapters.
                Note that if a chapter does not have the language requested, it will be skipped.

        Returns:
            A list of Chapter objects.
        &#34;&#34;&#34;

        chapters = []

        for cid in cids.split(&#34;,&#34;):

            if &#34;-&#34; in cid:
                start, end = cid.split(&#34;-&#34;)
                chapters.extend(self[start:end:lang])  # type: ignore

            else:
                langs = self.chapters[cid]
                chapter = langs.get(lang)

                if chapter is not None:
                    chapters.append(chapter)

        return chapters

    def parsed(self) -&gt; bool:
        &#34;&#34;&#34;Check whether this manga has been parsed (has at least one chapter).&#34;&#34;&#34;
        return len(self.chapters) &gt;= 1

    def __getitem__(self, key):
        if isinstance(key, slice):
            sorted_chapters = natsort.natsorted(self.chapters.keys())

            try:
                start = sorted_chapters.index(key.start)
                if key.stop is not None:
                    # include the last chapter also
                    stop = sorted_chapters.index(key.stop, start) + 1
                else:
                    stop = len(sorted_chapters)
            except ValueError:
                return []

            lang = &#34;en&#34; if key.step is None else key.step

            return [
                self.chapters[c][lang]
                for c in sorted_chapters[start:stop]
                if lang in self.chapters[c]
            ]

        else:
            return self.chapters[key]

    def __enter__(self):
        return self

    def __exit__(self, t, v, tb):
        self.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tankobon.models.Chapter"><code class="flex name class">
<span>class <span class="ident">Chapter</span></span>
<span>(</span><span>id: str, url: str, title: str = '', volume: str = '0', lang: str = 'en', pages: List[str] = &lt;factory&gt;, other: Dict[str, Any] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>A manga chapter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>The chapter id as a string (i.e 1, 2, 10a, etc.).</dd>
<dt><strong><code>url</code></strong></dt>
<dd>The chapter url.</dd>
<dt><strong><code>title</code></strong></dt>
<dd>The chapter name.</dd>
<dt><strong><code>volume</code></strong></dt>
<dd>The volume the chapter belongs to.</dd>
<dt><strong><code>lang</code></strong></dt>
<dd>The RFC 5646 (IETF) language code that this chapter was translated to.
(i.e 'en' - English)</dd>
<dt><strong><code>pages</code></strong></dt>
<dd>A list of image urls to the chapter pages.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Miscellanious map of keys to values.
May be used by parsers to store parser-specific info (keep state).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Chapter:
    &#34;&#34;&#34;A manga chapter.

    Args:
        id: The chapter id as a string (i.e 1, 2, 10a, etc.).
        url: The chapter url.
        title: The chapter name.
        volume: The volume the chapter belongs to.
        lang: The RFC 5646 (IETF) language code that this chapter was translated to.
            (i.e &#39;en&#39; - English)
        pages: A list of image urls to the chapter pages.
        other: Miscellanious map of keys to values.
            May be used by parsers to store parser-specific info (keep state).
    &#34;&#34;&#34;

    id: str
    url: str
    title: str = &#34;&#34;
    volume: str = &#34;0&#34;
    lang: str = &#34;en&#34;

    pages: List[str] = _list()

    other: Dict[str, Any] = _dict()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tankobon.models.Chapter.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Chapter.lang"><code class="name">var <span class="ident">lang</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Chapter.other"><code class="name">var <span class="ident">other</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Chapter.pages"><code class="name">var <span class="ident">pages</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Chapter.title"><code class="name">var <span class="ident">title</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Chapter.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Chapter.volume"><code class="name">var <span class="ident">volume</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="tankobon.models.Manga"><code class="flex name class">
<span>class <span class="ident">Manga</span></span>
<span>(</span><span>metadata: <a title="tankobon.models.Metadata" href="#tankobon.models.Metadata">Metadata</a>, chapters: Optional[dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A manga.</p>
<p>Selecting chapters in this manga can be done by slicing:</p>
<p>manga[start_cid:end_cid:lang]
# returns a list of Chapter objects</p>
<p>where start_cid is the first chapter of the selection, and end_cid is the last chapter of the selection.
lang is the ISO 639-1 language code of the chapters to select. i.e:</p>
<h1 id="select-chapters-1-to-5-in-the-spanish-language-inclusive-of-chapter-5">Select chapters 1 to 5 in the Spanish language (inclusive of chapter 5).</h1>
<h1 id="note-if-the-chapter-does-not-have-a-translation-for-the-selected-language">NOTE: If the chapter does not have a translation for the selected language,</h1>
<h1 id="the-number-of-chapters-you-get-may-not-be-the-number-requested">the number of chapters you get may not be the number requested!</h1>
<p>chapters = manga["1":"5":"es"]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>meta</code></strong></dt>
<dd>The manga metadata.</dd>
<dt><strong><code>chapters</code></strong></dt>
<dd>The manga chapters.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>chapters</code></strong></dt>
<dd>
<p>A map of chapter ids to a map of ISO 639-1 language codes to Chapter objects (chapters may have several languages):</p>
<p>{
// chapter id
"1": {
// ISO 639-1 language code
"en": Chapter(&hellip;)
}
}</p>
</dd>
<dt><strong><code>info</code></strong></dt>
<dd>
<p>A dictionary which has the following keys:</p>
<p>chapters (int)
The total number of chapters across all languages.</p>
<p>volumes (set)
The volumes that this manga has across all languages.</p>
<p>langs (set)
ISO 639-1 language codes that this manga was translated to.
Note that chapters may not have a translation for all language codes.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Manga:
    &#34;&#34;&#34;A manga.

    Selecting chapters in this manga can be done by slicing:

    manga[start_cid:end_cid:lang]  # returns a list of Chapter objects

    where start_cid is the first chapter of the selection, and end_cid is the last chapter of the selection.
    lang is the ISO 639-1 language code of the chapters to select. i.e:

    # Select chapters 1 to 5 in the Spanish language (inclusive of chapter 5).
    # NOTE: If the chapter does not have a translation for the selected language,
    # the number of chapters you get may not be the number requested!
    chapters = manga[&#34;1&#34;:&#34;5&#34;:&#34;es&#34;]

    Args:
        meta: The manga metadata.
        chapters: The manga chapters.

    Attributes:
        chapters: A map of chapter ids to a map of ISO 639-1 language codes to Chapter objects (chapters may have several languages):

            {
                // chapter id
                &#34;1&#34;: {
                    // ISO 639-1 language code
                    &#34;en&#34;: Chapter(...)
                }
            }

        info: A dictionary which has the following keys:

            chapters (int)
                The total number of chapters across all languages.

            volumes (set)
                The volumes that this manga has across all languages.

            langs (set)
                ISO 639-1 language codes that this manga was translated to.
                Note that chapters may not have a translation for all language codes.
    &#34;&#34;&#34;

    def __init__(
        self,
        metadata: Metadata,
        chapters: Optional[dict] = None,
    ):
        self.meta = metadata

        self.chapters: Dict[str, Dict[str, Chapter]]

        self.chapters = collections.defaultdict(dict)

        if chapters is not None:
            self.chapters.update(chapters)

    @property
    def info(self):
        info = {
            &#34;chapters&#34;: 0,
            &#34;volumes&#34;: set(),
            &#34;langs&#34;: set(),
        }

        for cid, langs in self.chapters.items():
            info[&#34;langs&#34;].update(langs.keys())

            for chapter in langs.values():
                info[&#34;chapters&#34;] += 1
                info[&#34;volumes&#34;].add(chapter.volume)

        return info

    def add(self, chapter: Chapter):
        &#34;&#34;&#34;Add a chapter to this manga.
        The chapter will not be added if it already exists (has the same id and lang as the existing one).

        Args:
            chapter: The chapter to add.
        &#34;&#34;&#34;

        if not self.exists(chapter):
            self.chapters[chapter.id][chapter.lang] = chapter

    def remove(self, cid: str, lang: str = &#34;en&#34;) -&gt; Chapter:
        &#34;&#34;&#34;Remove a chapter from this manga.

        Args:
            cid: The chapter id to remove.
            lang: The chapter language to remove.
                Defaults to &#39;en&#39;.

        Returns:
            The removed chapter.
        &#34;&#34;&#34;

        return self.chapters[cid].pop(lang)

    def exists(self, chapter: Chapter) -&gt; bool:
        &#34;&#34;&#34;Check whether a chapter already exists in this manga.

        Args:
            chapter: The chapter object.

        Returns:
            True if it exists, otherwise False.
        &#34;&#34;&#34;

        langs = self.chapters.get(chapter.id, {})

        return bool(langs) and chapter.lang in langs

    def dump(self) -&gt; dict:
        &#34;&#34;&#34;Serialise this manga to a dict.&#34;&#34;&#34;
        return {&#34;meta&#34;: self.meta, &#34;chapters&#34;: self.chapters}

    @classmethod
    def load(cls, data: dict) -&gt; Manga:
        &#34;&#34;&#34;Deserialise this manga from a dict.

        Args:
            data: The serialised manga.

        Returns:
            The Manga object.
        &#34;&#34;&#34;
        return cls(data[&#34;meta&#34;], chapters=data[&#34;chapters&#34;])  # type: ignore

    def summary(self, lang: str = &#34;en&#34;, link: bool = True) -&gt; str:
        &#34;&#34;&#34;Create a Markdown table summary of all volumes and chapters in this manga.

        Args:
            lang: The language to summerise for.
            link: Whether or not to add URL links.
                Defaults to True.

        Returns:
            The Markdown table as a string.
        &#34;&#34;&#34;

        table = [&#34;| volume | chapter | title &#34;, &#34;|--------|---------|-------&#34;]

        for cid, langs in natsort.natsorted(self.chapters.items()):

            chapter: Chapter = langs.get(lang)

            if chapter is None:
                # chapter does not have the language.
                continue

            table.append(
                &#34;| {:&lt;6} | {:&lt;7} | {}&#34;.format(
                    chapter.volume or &#34;(empty)&#34;,
                    chapter.id or &#34;(empty)&#34;,
                    f&#34;[{chapter.title or &#39;(empty)&#39;}]({chapter.url})&#34;
                    if link
                    else chapter.title or &#34;(empty)&#34;,
                )
            )

        if len(table) == 2:
            table.append(
                f&#34;(No chapters available for the language &#39;{lang}&#39;. Maybe try another one?)&#34;
            )

        return &#34;\n&#34;.join(table)

    def select(self, cids: str, lang: str = &#34;en&#34;) -&gt; List[Chapter]:
        &#34;&#34;&#34;Select chapters from this manga.

        Args:
            cids: A list of chapter ids as a string, delimited by a comma.
                Ranges are also valid (1-5).
                i.e &#39;1,3,5,8-10&#39; (select chapters 1,3,5 and 8-10 inclusive of 10).
            lang: The language of the chapters.
                Note that if a chapter does not have the language requested, it will be skipped.

        Returns:
            A list of Chapter objects.
        &#34;&#34;&#34;

        chapters = []

        for cid in cids.split(&#34;,&#34;):

            if &#34;-&#34; in cid:
                start, end = cid.split(&#34;-&#34;)
                chapters.extend(self[start:end:lang])  # type: ignore

            else:
                langs = self.chapters[cid]
                chapter = langs.get(lang)

                if chapter is not None:
                    chapters.append(chapter)

        return chapters

    def parsed(self) -&gt; bool:
        &#34;&#34;&#34;Check whether this manga has been parsed (has at least one chapter).&#34;&#34;&#34;
        return len(self.chapters) &gt;= 1

    def __getitem__(self, key):
        if isinstance(key, slice):
            sorted_chapters = natsort.natsorted(self.chapters.keys())

            try:
                start = sorted_chapters.index(key.start)
                if key.stop is not None:
                    # include the last chapter also
                    stop = sorted_chapters.index(key.stop, start) + 1
                else:
                    stop = len(sorted_chapters)
            except ValueError:
                return []

            lang = &#34;en&#34; if key.step is None else key.step

            return [
                self.chapters[c][lang]
                for c in sorted_chapters[start:stop]
                if lang in self.chapters[c]
            ]

        else:
            return self.chapters[key]

    def __enter__(self):
        return self

    def __exit__(self, t, v, tb):
        self.close()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tankobon.models.Manga.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>data: dict) ‑> <a title="tankobon.models.Manga" href="#tankobon.models.Manga">Manga</a></span>
</code></dt>
<dd>
<div class="desc"><p>Deserialise this manga from a dict.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The serialised manga.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The Manga object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, data: dict) -&gt; Manga:
    &#34;&#34;&#34;Deserialise this manga from a dict.

    Args:
        data: The serialised manga.

    Returns:
        The Manga object.
    &#34;&#34;&#34;
    return cls(data[&#34;meta&#34;], chapters=data[&#34;chapters&#34;])  # type: ignore</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tankobon.models.Manga.info"><code class="name">var <span class="ident">info</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info(self):
    info = {
        &#34;chapters&#34;: 0,
        &#34;volumes&#34;: set(),
        &#34;langs&#34;: set(),
    }

    for cid, langs in self.chapters.items():
        info[&#34;langs&#34;].update(langs.keys())

        for chapter in langs.values():
            info[&#34;chapters&#34;] += 1
            info[&#34;volumes&#34;].add(chapter.volume)

    return info</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tankobon.models.Manga.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, chapter: <a title="tankobon.models.Chapter" href="#tankobon.models.Chapter">Chapter</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a chapter to this manga.
The chapter will not be added if it already exists (has the same id and lang as the existing one).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chapter</code></strong></dt>
<dd>The chapter to add.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, chapter: Chapter):
    &#34;&#34;&#34;Add a chapter to this manga.
    The chapter will not be added if it already exists (has the same id and lang as the existing one).

    Args:
        chapter: The chapter to add.
    &#34;&#34;&#34;

    if not self.exists(chapter):
        self.chapters[chapter.id][chapter.lang] = chapter</code></pre>
</details>
</dd>
<dt id="tankobon.models.Manga.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Serialise this manga to a dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self) -&gt; dict:
    &#34;&#34;&#34;Serialise this manga to a dict.&#34;&#34;&#34;
    return {&#34;meta&#34;: self.meta, &#34;chapters&#34;: self.chapters}</code></pre>
</details>
</dd>
<dt id="tankobon.models.Manga.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, chapter: <a title="tankobon.models.Chapter" href="#tankobon.models.Chapter">Chapter</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether a chapter already exists in this manga.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chapter</code></strong></dt>
<dd>The chapter object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if it exists, otherwise False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, chapter: Chapter) -&gt; bool:
    &#34;&#34;&#34;Check whether a chapter already exists in this manga.

    Args:
        chapter: The chapter object.

    Returns:
        True if it exists, otherwise False.
    &#34;&#34;&#34;

    langs = self.chapters.get(chapter.id, {})

    return bool(langs) and chapter.lang in langs</code></pre>
</details>
</dd>
<dt id="tankobon.models.Manga.parsed"><code class="name flex">
<span>def <span class="ident">parsed</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether this manga has been parsed (has at least one chapter).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parsed(self) -&gt; bool:
    &#34;&#34;&#34;Check whether this manga has been parsed (has at least one chapter).&#34;&#34;&#34;
    return len(self.chapters) &gt;= 1</code></pre>
</details>
</dd>
<dt id="tankobon.models.Manga.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, cid: str, lang: str = 'en') ‑> <a title="tankobon.models.Chapter" href="#tankobon.models.Chapter">Chapter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Remove a chapter from this manga.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cid</code></strong></dt>
<dd>The chapter id to remove.</dd>
<dt><strong><code>lang</code></strong></dt>
<dd>The chapter language to remove.
Defaults to 'en'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The removed chapter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, cid: str, lang: str = &#34;en&#34;) -&gt; Chapter:
    &#34;&#34;&#34;Remove a chapter from this manga.

    Args:
        cid: The chapter id to remove.
        lang: The chapter language to remove.
            Defaults to &#39;en&#39;.

    Returns:
        The removed chapter.
    &#34;&#34;&#34;

    return self.chapters[cid].pop(lang)</code></pre>
</details>
</dd>
<dt id="tankobon.models.Manga.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, cids: str, lang: str = 'en') ‑> List[<a title="tankobon.models.Chapter" href="#tankobon.models.Chapter">Chapter</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Select chapters from this manga.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cids</code></strong></dt>
<dd>A list of chapter ids as a string, delimited by a comma.
Ranges are also valid (1-5).
i.e '1,3,5,8-10' (select chapters 1,3,5 and 8-10 inclusive of 10).</dd>
<dt><strong><code>lang</code></strong></dt>
<dd>The language of the chapters.
Note that if a chapter does not have the language requested, it will be skipped.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of Chapter objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, cids: str, lang: str = &#34;en&#34;) -&gt; List[Chapter]:
    &#34;&#34;&#34;Select chapters from this manga.

    Args:
        cids: A list of chapter ids as a string, delimited by a comma.
            Ranges are also valid (1-5).
            i.e &#39;1,3,5,8-10&#39; (select chapters 1,3,5 and 8-10 inclusive of 10).
        lang: The language of the chapters.
            Note that if a chapter does not have the language requested, it will be skipped.

    Returns:
        A list of Chapter objects.
    &#34;&#34;&#34;

    chapters = []

    for cid in cids.split(&#34;,&#34;):

        if &#34;-&#34; in cid:
            start, end = cid.split(&#34;-&#34;)
            chapters.extend(self[start:end:lang])  # type: ignore

        else:
            langs = self.chapters[cid]
            chapter = langs.get(lang)

            if chapter is not None:
                chapters.append(chapter)

    return chapters</code></pre>
</details>
</dd>
<dt id="tankobon.models.Manga.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self, lang: str = 'en', link: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Markdown table summary of all volumes and chapters in this manga.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lang</code></strong></dt>
<dd>The language to summerise for.</dd>
<dt><strong><code>link</code></strong></dt>
<dd>Whether or not to add URL links.
Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The Markdown table as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(self, lang: str = &#34;en&#34;, link: bool = True) -&gt; str:
    &#34;&#34;&#34;Create a Markdown table summary of all volumes and chapters in this manga.

    Args:
        lang: The language to summerise for.
        link: Whether or not to add URL links.
            Defaults to True.

    Returns:
        The Markdown table as a string.
    &#34;&#34;&#34;

    table = [&#34;| volume | chapter | title &#34;, &#34;|--------|---------|-------&#34;]

    for cid, langs in natsort.natsorted(self.chapters.items()):

        chapter: Chapter = langs.get(lang)

        if chapter is None:
            # chapter does not have the language.
            continue

        table.append(
            &#34;| {:&lt;6} | {:&lt;7} | {}&#34;.format(
                chapter.volume or &#34;(empty)&#34;,
                chapter.id or &#34;(empty)&#34;,
                f&#34;[{chapter.title or &#39;(empty)&#39;}]({chapter.url})&#34;
                if link
                else chapter.title or &#34;(empty)&#34;,
            )
        )

    if len(table) == 2:
        table.append(
            f&#34;(No chapters available for the language &#39;{lang}&#39;. Maybe try another one?)&#34;
        )

    return &#34;\n&#34;.join(table)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tankobon.models.Metadata"><code class="flex name class">
<span>class <span class="ident">Metadata</span></span>
<span>(</span><span>url: str, title: str = '', alt_titles: List[str] = &lt;factory&gt;, desc: Dict[str, str] = &lt;factory&gt;, cover: str = '', authors: List[str] = &lt;factory&gt;, genres: List[str] = &lt;factory&gt;, hash: str = '', other: Dict[str, Any] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Metadata for a manga.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong></dt>
<dd>The url to the manga title page.</dd>
<dt><strong><code>title</code></strong></dt>
<dd>The manga name in English (romanized/translated).</dd>
<dt><strong><code>alt_titles</code></strong></dt>
<dd>A list of alternative names for the manga.
i.e in another language, original Japanese name, etc.</dd>
<dt><strong><code>desc</code></strong></dt>
<dd>The sypnosis (human-readable info) of the manga.
This is a map of the ISO 639-1 language code to the localised description.
At least 'en' (English) should be present.</dd>
<dt><strong><code>cover</code></strong></dt>
<dd>The url to the manga cover page (must be an image).</dd>
<dt><strong><code>authors</code></strong></dt>
<dd>A list of author names.</dd>
<dt><strong><code>genres</code></strong></dt>
<dd>A list of catagories the manga belongs to.
i.e shounen, slice_of_life, etc.
Note that the catagories are sanitised using utils.sanitise() on initalisation.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>Miscellanious map of keys to values.
May be used by parsers to store parser-specific info (keep state).</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>hash</code></strong></dt>
<dd>A SHA-256 checksum of the manga url.
(Can be used for filename-safe manga storage.)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Metadata:
    &#34;&#34;&#34;Metadata for a manga.

    Args:
        url: The url to the manga title page.
        title: The manga name in English (romanized/translated).
        alt_titles: A list of alternative names for the manga.
            i.e in another language, original Japanese name, etc.
        desc: The sypnosis (human-readable info) of the manga.
            This is a map of the ISO 639-1 language code to the localised description.
            At least &#39;en&#39; (English) should be present.
        cover: The url to the manga cover page (must be an image).
        authors: A list of author names.
        genres: A list of catagories the manga belongs to.
            i.e shounen, slice_of_life, etc.
            Note that the catagories are sanitised using utils.sanitise() on initalisation.
        other: Miscellanious map of keys to values.
            May be used by parsers to store parser-specific info (keep state).

    Attributes:
        hash: A SHA-256 checksum of the manga url.
            (Can be used for filename-safe manga storage.)
    &#34;&#34;&#34;

    url: str
    title: str = &#34;&#34;

    alt_titles: List[str] = _list()

    desc: Dict[str, str] = _dict()
    cover: str = &#34;&#34;

    authors: List[str] = _list()
    genres: List[str] = _list()

    hash: str = &#34;&#34;

    other: Dict[str, Any] = _dict()

    def __post_init__(self):
        if self.genres:
            self.genres = [utils.sanitize(g.strip()) for g in self.genres]

        for lang, localized in self.desc.items():
            self.desc[lang] = localized.strip().replace(&#34;\r\n&#34;, &#34;\n&#34;)

        if not self.hash:
            self.hash = hashlib.sha256(self.url.encode()).hexdigest()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tankobon.models.Metadata.alt_titles"><code class="name">var <span class="ident">alt_titles</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Metadata.authors"><code class="name">var <span class="ident">authors</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Metadata.cover"><code class="name">var <span class="ident">cover</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Metadata.desc"><code class="name">var <span class="ident">desc</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Metadata.genres"><code class="name">var <span class="ident">genres</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Metadata.hash"><code class="name">var <span class="ident">hash</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Metadata.other"><code class="name">var <span class="ident">other</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Metadata.title"><code class="name">var <span class="ident">title</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tankobon.models.Metadata.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tankobon" href="index.html">tankobon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tankobon.models.Chapter" href="#tankobon.models.Chapter">Chapter</a></code></h4>
<ul class="two-column">
<li><code><a title="tankobon.models.Chapter.id" href="#tankobon.models.Chapter.id">id</a></code></li>
<li><code><a title="tankobon.models.Chapter.lang" href="#tankobon.models.Chapter.lang">lang</a></code></li>
<li><code><a title="tankobon.models.Chapter.other" href="#tankobon.models.Chapter.other">other</a></code></li>
<li><code><a title="tankobon.models.Chapter.pages" href="#tankobon.models.Chapter.pages">pages</a></code></li>
<li><code><a title="tankobon.models.Chapter.title" href="#tankobon.models.Chapter.title">title</a></code></li>
<li><code><a title="tankobon.models.Chapter.url" href="#tankobon.models.Chapter.url">url</a></code></li>
<li><code><a title="tankobon.models.Chapter.volume" href="#tankobon.models.Chapter.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tankobon.models.Manga" href="#tankobon.models.Manga">Manga</a></code></h4>
<ul class="two-column">
<li><code><a title="tankobon.models.Manga.add" href="#tankobon.models.Manga.add">add</a></code></li>
<li><code><a title="tankobon.models.Manga.dump" href="#tankobon.models.Manga.dump">dump</a></code></li>
<li><code><a title="tankobon.models.Manga.exists" href="#tankobon.models.Manga.exists">exists</a></code></li>
<li><code><a title="tankobon.models.Manga.info" href="#tankobon.models.Manga.info">info</a></code></li>
<li><code><a title="tankobon.models.Manga.load" href="#tankobon.models.Manga.load">load</a></code></li>
<li><code><a title="tankobon.models.Manga.parsed" href="#tankobon.models.Manga.parsed">parsed</a></code></li>
<li><code><a title="tankobon.models.Manga.remove" href="#tankobon.models.Manga.remove">remove</a></code></li>
<li><code><a title="tankobon.models.Manga.select" href="#tankobon.models.Manga.select">select</a></code></li>
<li><code><a title="tankobon.models.Manga.summary" href="#tankobon.models.Manga.summary">summary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tankobon.models.Metadata" href="#tankobon.models.Metadata">Metadata</a></code></h4>
<ul class="two-column">
<li><code><a title="tankobon.models.Metadata.alt_titles" href="#tankobon.models.Metadata.alt_titles">alt_titles</a></code></li>
<li><code><a title="tankobon.models.Metadata.authors" href="#tankobon.models.Metadata.authors">authors</a></code></li>
<li><code><a title="tankobon.models.Metadata.cover" href="#tankobon.models.Metadata.cover">cover</a></code></li>
<li><code><a title="tankobon.models.Metadata.desc" href="#tankobon.models.Metadata.desc">desc</a></code></li>
<li><code><a title="tankobon.models.Metadata.genres" href="#tankobon.models.Metadata.genres">genres</a></code></li>
<li><code><a title="tankobon.models.Metadata.hash" href="#tankobon.models.Metadata.hash">hash</a></code></li>
<li><code><a title="tankobon.models.Metadata.other" href="#tankobon.models.Metadata.other">other</a></code></li>
<li><code><a title="tankobon.models.Metadata.title" href="#tankobon.models.Metadata.title">title</a></code></li>
<li><code><a title="tankobon.models.Metadata.url" href="#tankobon.models.Metadata.url">url</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>